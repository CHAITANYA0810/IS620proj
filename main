Set Serveroutput on;

DROP TABLE Recommendation CASCADE CONSTRAINTS;
DROP TABLE Reviews CASCADE CONSTRAINTS;
DROP TABLE Invoices CASCADE CONSTRAINTS;
DROP TABLE Orders CASCADE CONSTRAINTS;
DROP TABLE Products CASCADE CONSTRAINTS;
DROP TABLE Product_Category CASCADE CONSTRAINTS;
DROP TABLE Credit_Cards CASCADE CONSTRAINTS;
DROP TABLE Customers CASCADE CONSTRAINTS;

CREATE TABLE Customers (
  Customer_ID INT PRIMARY KEY,
  F_Name VARCHAR(50),
  L_Name VARCHAR(50),
  email VARCHAR(100),
  City VARCHAR(50),
  State VARCHAR(50),
  Zip INT
);

CREATE TABLE Credit_Cards (
  Card_number INT PRIMARY KEY, 
  Customer_ID INT,
  Card_type VARCHAR(10),
  Expiration_year INT,
  Expiration_month INT,
  FOREIGN KEY (Customer_ID) REFERENCES Customers(Customer_ID)
);

CREATE TABLE Product_Category(
    ProductCategory_ID NUMBER PRIMARY KEY,
    ProductCategory_Name VARCHAR(30),
    ProductCategory_Desc VARCHAR(100)
    );

CREATE TABLE Products (
    Product_ID NUMBER,
    ProductCategory_ID NUMBER,
    Product_Name VARCHAR(30),
    Avail_Quant NUMBER,
    Unitprice NUMBER,
    primary key (Product_id),
    foreign key (ProductCategory_ID) references Product_Category(ProductCategory_ID)
);

CREATE TABLE Orders (
    Order_ID number ,
    Customer_ID number,
    Product_ID number,
    Quantity number,
    Order_Date date,
    primary key (Order_ID),
    foreign key (Customer_ID) references Customers(Customer_ID),
    foreign key (Product_ID) references Products(Product_ID)
);

CREATE TABLE Invoices (
    Invoice_ID NUMBER PRIMARY KEY,
    Order_ID NUMBER REFERENCES Orders(Order_ID),
    Customer_ID NUMBER REFERENCES Customers(Customer_ID),
    CreditCardNumber VARCHAR2(20),
    Amount NUMBER
);

CREATE TABLE Reviews (
    Review_ID NUMBER PRIMARY KEY,
    Product_ID NUMBER REFERENCES Products(Product_ID),
    ReviewerEmail VARCHAR2(255),
    StarsGiven NUMBER(1, 0),
    ReviewText CLOB
);

CREATE TABLE Recommendation (
    Recommendation_ID NUMBER PRIMARY KEY,
    Customer_ID NUMBER REFERENCES Customers(Customer_ID),
    RecommendedProduct_ID NUMBER REFERENCES Products(Product_ID),
    RecommendationDate DATE
);

desc Customers;
desc Credit_Cards;
desc Product_Category;
desc Products;
desc Orders;
desc Invoices;
desc Reviews;
desc Recommendation;

drop sequence customer_id_seq;

CREATE SEQUENCE customer_id_seq START WITH 1;
--Adding Customers into the table
create or replace procedure Add_Customer(cust in INT ,
  fnam in VARCHAR,
  lnam in VARCHAR,
  mail in VARCHAR,
  cit in VARCHAR,
  stat in VARCHAR,
  zipp in VARCHAR) as
x customers%rowtype;
begin
    x.customer_ID:=cust;
    x.f_name:=fnam;
    x.l_name:=lnam;
    x.email:=mail;
    x.city:=cit;
    x.state:=stat;
    x.zip:=zipp;
    
INSERT INTO CUSTOMERS VALUES  x;
COMMIT;
dbms_output.put_line('ADDING CUSTOMER '||x.f_name||' '||x.l_name);
EXCEPTION
    WHEN OTHERS THEN
        -- Handle exceptions
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

------
CREATE OR REPLACE FUNCTION FIND_CUSTOMER_ID(p_email IN VARCHAR2) RETURN NUMBER AS
    v_customer_id NUMBER;
BEGIN
    -- Find the customer ID based on the email
    SELECT customer_id INTO v_customer_id FROM Customers WHERE email = p_email;
    RETURN v_customer_id;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        -- Handle the case when no customer is found for the given email
        RETURN NULL;
    WHEN OTHERS THEN
        -- Handle other exceptions
        RETURN NULL;
END;


-----
CREATE OR REPLACE PROCEDURE Add_CreditCard(
    p_email IN VARCHAR2,
    p_credit_card_number IN VARCHAR2,
    p_card_type IN VARCHAR2,
    p_exp_year IN NUMBER,
    p_exp_month IN NUMBER
) AS
    v_customer_id NUMBER;
BEGIN
    -- Find the customer ID using the helper function
    v_customer_id := FIND_CUSTOMER_ID(p_email);

    IF v_customer_id IS NOT NULL THEN
        -- Insert the new credit card into the CreditCards table
        INSERT INTO Credit_Cards(customer_id, card_number, card_type, expiration_year, expiration_month)
        VALUES (v_customer_id, p_credit_card_number, p_card_type, p_exp_year, p_exp_month);

        DBMS_OUTPUT.PUT_LINE('Credit card added successfully.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Customer not found for the given email.');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        -- Handle exceptions
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;


CREATE OR REPLACE PROCEDURE Show_all_customers_in_state(p_state IN VARCHAR2) AS
BEGIN
    -- Display a list of all customers in the specified state
    FOR cust IN (SELECT c.F_name, c.L_name, c.email, c.city, c.state, c.zip, cc.Card_number, cc.Card_type
                 FROM Customers c
                 JOIN Credit_Cards cc ON c.customer_id = cc.customer_id
                 WHERE c.state = p_state) 
    LOOP
        DBMS_OUTPUT.PUT_LINE('Name: ' || cust.F_name ||  cust.L_name || ', Email: ' || cust.email ||
                             ', City: ' || cust.city || ', State: ' || cust.state ||
                             ', Zip: ' || cust.zip || ', Credit Card: ' || cust.card_number ||
                             ', Card Type: ' || cust.card_type);
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        -- Handle exceptions
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

create or replace procedure Add_CreditCard(cardno in int,CustoID in INT,cardty in VARCHAR,expyear in int,expmonth in int)as
y Credit_Cards%rowtype;
begin
    y.card_number:=cardno;
    y.customer_id:=CustoID;
    y.card_type:=cardty;
    y.expiration_year:=expyear;
    y.expiration_month:=expmonth;
INSERT INTO Credit_Cards VALUES y;
dbms_output.put_line('ADDING CREDIT CARD WITH CARD NUMBER '||y.card_number);
END;

-- Drop sequences
DROP SEQUENCE Category_id_Seq;
DROP SEQUENCE Product_id_Seq;

-- Create the sequence Category_Seq
CREATE SEQUENCE Category_id_Seq START WITH 1 INCREMENT BY 1;
-- Create the sequence Product_Seq
CREATE SEQUENCE Product_id_Seq START WITH 1 INCREMENT BY 1;

-- Procedure to add a new product category
CREATE OR REPLACE PROCEDURE Add_Category(
    p_ProductCategory_Name IN VARCHAR2,
    p_ProductCategory_Desc IN VARCHAR2
) AS
BEGIN
    INSERT INTO Product_Category(ProductCategory_ID, ProductCategory_Name, ProductCategory_Desc)
    VALUES (Category_id_Seq.NEXTVAL, p_ProductCategory_Name, p_ProductCategory_Desc);
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Product category added successfully');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

-- Procedure to add a new product
CREATE OR REPLACE PROCEDURE Add_Product(
    p_Product_Name IN VARCHAR2,
    p_Avail_Quant IN NUMBER,
    p_UnitPrice IN NUMBER,
    p_ProductCategory_Name IN VARCHAR2
) AS
    v_ProductCategory_ID NUMBER;
BEGIN
    -- Find the category ID using the category name
    SELECT ProductCategory_ID INTO v_ProductCategory_ID
    FROM Product_Category
    WHERE ProductCategory_Name = p_ProductCategory_Name;

    -- Insert the product information
    INSERT INTO Products(Product_ID, Product_Name, Avail_Quant, Unitprice, ProductCategory_ID)
    VALUES (Product_id_Seq.NEXTVAL, p_Product_Name, p_Avail_Quant, p_UnitPrice, v_ProductCategory_ID);
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Product added successfully');
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error: Category not found.');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

CREATE OR REPLACE PROCEDURE Update_Inventory(
    p_product_id IN NUMBER,
    p_units IN NUMBER
) AS
    v_existing_quantity NUMBER;
BEGIN
    -- Use cursor to fetch existing quantity
    FOR product_rec IN (SELECT Avail_quant FROM Products WHERE product_id = p_product_id) 
    LOOP
        v_existing_quantity := product_rec.Avail_Quant;
    END LOOP;

    -- Update inventory
    UPDATE Products
    SET Avail_quant = v_existing_quantity - p_units
    WHERE product_id = p_product_id;

    DBMS_OUTPUT.PUT_LINE('Inventory updated successfully.');
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error: Product with ID ' || p_product_id || ' not found.');
    WHEN OTHERS THEN
        -- Handle exceptions
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

CREATE OR REPLACE PROCEDURE Report_Inventory AS
BEGIN
    -- Use cursor to fetch inventory information
    FOR category_rec IN (SELECT ProductCategory_id, ProductCategory_name FROM Product_Category)
    LOOP
        DBMS_OUTPUT.PUT_LINE('Category: ' || category_rec.ProductCategory_name);

        FOR product_rec IN (SELECT product_name, Avail_Quant FROM Products WHERE ProductCategory_id = category_rec.ProductCategory_id)
        LOOP
            DBMS_OUTPUT.PUT_LINE('  Product: ' || product_rec.product_name || ', Quantity: ' || product_rec.Avail_quant);
        END LOOP;
    END LOOP;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error: No data found in the inventory.');
    WHEN OTHERS THEN
        -- Handle exceptions
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

CREATE OR REPLACE FUNCTION FIND_PRODUCT_ID(
    p_product_name IN VARCHAR2
) RETURN NUMBER IS
    v_product_id Products.Product_ID%TYPE;
BEGIN
    SELECT Product_ID
    INTO v_product_id
    FROM Products
    WHERE Product_Name = p_product_name;

    RETURN v_product_id;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        -- Handle exception when product is not found
        DBMS_OUTPUT.PUT_LINE('Error: Product not found.');
        RETURN NULL; -- You can choose to handle this differently based on your requirements
    WHEN OTHERS THEN
        -- Handle other exceptions
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
        RETURN NULL; -- You can choose to handle this differently based on your requirements
END;

-- Drop the sequence Order_Seq
DROP SEQUENCE Order_id_Seq;

-- Create the sequence Order_Seq
CREATE SEQUENCE Order_id_Seq START WITH 1 INCREMENT BY 1;

CREATE OR REPLACE PROCEDURE Place_Order(
    p_customer_email IN VARCHAR2,
    p_product_name IN VARCHAR2,
    p_quantity IN NUMBER,
    p_credit_card_number IN VARCHAR2
) AS
    v_customer_id Customers.Customer_ID%TYPE;
    v_product_id Products.Product_ID%TYPE;
    v_order_id Orders.Order_ID%TYPE;
BEGIN
    -- Find customer ID using helper function
    v_customer_id := FIND_CUSTOMER_ID(p_customer_email);

    -- Find product ID using helper function
    v_product_id := FIND_PRODUCT_ID(p_product_name);

    -- Insert order information
    INSERT INTO Orders(Order_ID, Customer_ID, Product_ID, Quantity, Order_Date)
    VALUES (Order_id_seq.NEXTVAL, v_customer_id, v_product_id, p_quantity, SYSDATE)
    RETURNING Order_ID INTO v_order_id;

    -- Update inventory using the procedure from Member 2
    Update_Inventory(v_product_id, p_quantity);

    -- Invoice the customer using the procedure from Member 4
    --Invoice_Customer(v_order_id, v_customer_id, p_credit_card_number, p_quantity);

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error: Customer or product not found.');
    WHEN OTHERS THEN
        -- Handle exceptions
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

CREATE OR REPLACE PROCEDURE SHOW_ORDERS IS
BEGIN
    FOR order_rec IN (SELECT
                        C.F_name AS Customer_Name,
                        P.Product_Name,
                        O.Quantity,
                        O.Quantity * P.UnitPrice AS Amount_Charged
                      FROM
                        Orders O
                        JOIN Customers C ON O.Customer_ID = C.Customer_ID
                        JOIN Products P ON O.Product_ID = P.Product_ID)
    LOOP
        DBMS_OUTPUT.PUT_LINE('Customer: ' || order_rec.Customer_Name ||
                             ', Product: ' || order_rec.Product_Name ||
                             ', Quantity Ordered: ' || order_rec.Quantity ||
                             ', Amount Charged: ' || order_rec.Amount_Charged);
    END LOOP;

    -- Calculate Grand Total
    DECLARE
        v_grand_total NUMBER;
    BEGIN
        SELECT SUM(Avail_Quant * UnitPrice)
        INTO v_grand_total
        FROM Products;

        DBMS_OUTPUT.PUT_LINE('Grand Total Amount of All Orders: ' || v_grand_total);
    END;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

CREATE OR REPLACE PROCEDURE REPORT_ORDERS_BY_STATE (p_state IN VARCHAR2) IS
BEGIN
    FOR order_rec IN (SELECT
                        C.F_Name AS Customer_Name,
                        C.Email,
                        COUNT(*) AS Total_Orders,
                        SUM(O.Quantity * P.UnitPrice) AS Total_Amount
                      FROM
                        Orders O
                        JOIN Customers C ON O.Customer_ID = C.Customer_ID
                        JOIN Products P ON O.Product_ID = P.Product_ID
                      WHERE
                        C.State = p_state
                      GROUP BY
                        C.F_Name, C.Email)
    LOOP
        DBMS_OUTPUT.PUT_LINE('Customer: ' || order_rec.Customer_Name ||
                             ', Email: ' || order_rec.Email ||
                             ', Total Orders: ' || order_rec.Total_Orders ||
                             ', Total Amount Spent: ' || order_rec.Total_Amount);
    END LOOP;

    -- Calculate Grand Total Amount Spent
    DECLARE
        v_grand_total NUMBER;
    BEGIN
        SELECT SUM(O.Quantity * P.UnitPrice)
        INTO v_grand_total
        FROM Orders O
        JOIN Customers C ON O.Customer_ID = C.Customer_ID
        JOIN Products P ON O.Product_ID = P.Product_ID
        WHERE C.State = p_state;

        DBMS_OUTPUT.PUT_LINE('Grand Total Amount Spent from ' || p_state || ': ' || v_grand_total);
    END;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

-- Create a stored procedure to get the product name
CREATE OR REPLACE PROCEDURE Get_Product_Name(
    p_Product_ID IN NUMBER,
    p_Product_Name OUT VARCHAR2
) AS
BEGIN
    SELECT Product_Name INTO p_Product_Name
    FROM Products
    WHERE Product_ID = p_Product_ID;
END;

-- Create the trigger
CREATE OR REPLACE TRIGGER Low_Inventory_Trigger
BEFORE INSERT ON Orders
FOR EACH ROW
DECLARE
    v_Avail_Quant NUMBER;
    v_Product_Name VARCHAR2(100); -- Adjust the size based on your actual column size
BEGIN
    -- Get the product name
    Get_Product_Name(:new.Product_ID, v_Product_Name);

    -- Get the available quantity
    SELECT Avail_Quant INTO v_Avail_Quant
    FROM Products
    WHERE Product_ID = :new.Product_ID;

    -- Check for low inventory
    IF v_Avail_Quant < 50 THEN
        DBMS_OUTPUT.PUT_LINE('Low Inventory Alert: Product ' || :new.Product_ID || ' (' || v_Product_Name || ') is below 50 units.');
    END IF;
END;

-- Procedure to restock a specific product
CREATE OR REPLACE PROCEDURE Restock_Product(
    p_Product_Name IN VARCHAR2,
    p_QuantityToAdd IN NUMBER
) AS
BEGIN
    -- Update the product's available quantity
    UPDATE Products
    SET Avail_Quant = Avail_Quant + p_QuantityToAdd
    WHERE Product_Name = p_Product_Name; -- Corrected the parameter name here
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Product restocked successfully');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

-- Helper Function: FIND_ORDER_ID
CREATE OR REPLACE FUNCTION FIND_ORDER_ID(p_customer_email VARCHAR2, p_product_name VARCHAR2, p_quantity NUMBER)
    RETURN NUMBER
IS
    v_customer_id   Customers.Customer_ID%TYPE;
    v_product_id    Products.Product_ID%TYPE;
    v_order_id      Orders.Order_ID%TYPE;
BEGIN
    -- Use FIND_CUSTOMER_ID, FIND_PRODUCT_ID functions as needed
    v_customer_id := FIND_CUSTOMER_ID(p_customer_email);
    v_product_id := FIND_PRODUCT_ID(p_product_name);

    -- Find Order ID based on customer, product, and quantity
    SELECT Order_ID
    INTO v_order_id
    FROM Orders
    WHERE Customer_ID = v_customer_id
        AND Product_ID = v_product_id
        AND Quantity = p_quantity;

    RETURN v_order_id;
END;

-- Helper Function: FIND_CREDIT_CARD_ID
CREATE OR REPLACE FUNCTION FIND_CREDIT_CARD_ID(p_credit_card_number VARCHAR2)
    RETURN INT
IS
    v_credit_card_id   Credit_Cards.Card_Number%TYPE; -- Assuming CreditCard_Number is unique
BEGIN
    -- Find Credit Card ID based on credit card number
    SELECT Customer_ID
    INTO v_credit_card_id
    FROM Credit_Cards
    WHERE Card_Number = p_credit_card_number;

    RETURN v_credit_card_id;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Credit card not found.');
        RETURN NULL;
END;

DROP SEQUENCE InvoiceID_SEQ

CREATE SEQUENCE InvoiceID_SEQ START WITH 1 INCREMENT BY 1;

-- Procedure: Invoice_Customer
CREATE OR REPLACE PROCEDURE Invoice_Customer(
    p_order_id IN Orders.Order_ID%TYPE,
    p_customer_id IN Customers.Customer_ID%TYPE,
    p_credit_card_number IN VARCHAR2,
    p_amount IN NUMBER
)
IS
    v_credit_card_id Credit_Cards.Card_Number%TYPE;
BEGIN
    -- Find Credit Card ID based on credit card number using helper function
    v_credit_card_id := FIND_CREDIT_CARD_ID(p_credit_card_number);

    -- Insert record into Invoice table
    INSERT INTO Invoices (Invoice_ID, Order_ID, Customer_ID, CreditCardNumber, Amount)
    VALUES (InvoiceID_Seq.NEXTVAL, p_order_id, p_customer_id, v_credit_card_id, p_amount);

    DBMS_OUTPUT.PUT_LINE('Invoice record added successfully.');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error adding invoice record: ' || SQLERRM);
END;

-- Procedure: Report_Best_Customers
CREATE OR REPLACE PROCEDURE Report_Best_Customers(
    p_amount_threshold IN NUMBER
)
IS
BEGIN
    -- Display report header
    DBMS_OUTPUT.PUT_LINE('Report of Customers Who Spent More Than $' || TO_CHAR(p_amount_threshold));
    DBMS_OUTPUT.PUT_LINE('--------------------------------------------');
    
    -- Query and display customers who spent more than the specified amount
    FOR cust IN (
        SELECT c.Customer_ID, c.F_Name, SUM(i.Amount) AS total_amount
        FROM Customers c
        JOIN Invoices i ON c.Customer_ID = i.Customer_ID
        GROUP BY c.Customer_ID, c.F_Name
        HAVING SUM(i.Amount) > p_amount_threshold
        ORDER BY total_amount DESC
    ) LOOP
        DBMS_OUTPUT.PUT_LINE('Customer ID: ' || cust.Customer_ID || ', Name: ' || cust.F_Name || ', Total Amount Spent: $' || TO_CHAR(cust.total_amount));
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error generating best customers report: ' || SQLERRM);
END Report_Best_Customers;

-- Procedure: Payments_to_CC
CREATE OR REPLACE PROCEDURE Payments_to_CC IS
    -- Declare variables
    v_total_visa_fee NUMBER;
    v_total_mc_fee NUMBER;
    v_total_amex_fee NUMBER;
    v_total_discover_fee NUMBER;

BEGIN
    -- Initialize variables
    v_total_visa_fee := 0;
    v_total_mc_fee := 0;
    v_total_amex_fee := 0;
    v_total_discover_fee := 0;

    -- Display report header
    DBMS_OUTPUT.PUT_LINE('Payments to Credit Card Companies');
    DBMS_OUTPUT.PUT_LINE('----------------------------------');

    -- Cursors for fetching payments by credit card type
    FOR payment IN (SELECT c.Card_Type, SUM(i.Amount) AS total_amount
                    FROM Credit_Cards c
                    JOIN Invoices i ON c.Card_Number = i.CreditCardNumber
                    GROUP BY c.Card_Type) LOOP

        -- Calculate fees based on credit card type
        CASE payment.Card_Type
            WHEN 'VISA' THEN
                v_total_visa_fee := payment.total_amount * 0.03;
            WHEN 'MC' THEN
                v_total_mc_fee := payment.total_amount * 0.03;
            WHEN 'AMEX' THEN
                v_total_amex_fee := payment.total_amount * 0.05;
            WHEN 'DISCOVER' THEN
                v_total_discover_fee := payment.total_amount * 0.02;
        END CASE;
    END LOOP;

    -- Display the calculated fees
    DBMS_OUTPUT.PUT_LINE('VISA Fee: $' || TO_CHAR(v_total_visa_fee));
    DBMS_OUTPUT.PUT_LINE('MC Fee: $' || TO_CHAR(v_total_mc_fee));
    DBMS_OUTPUT.PUT_LINE('AMEX Fee: $' || TO_CHAR(v_total_amex_fee));
    DBMS_OUTPUT.PUT_LINE('DISCOVER Fee: $' || TO_CHAR(v_total_discover_fee));

EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error calculating payments to credit card companies: ' || SQLERRM);
END;

-- Procedure: Thrifty_Customer
CREATE OR REPLACE PROCEDURE Thrifty_Customer(p_num_customers IN NUMBER) IS
    v_counter NUMBER := 0; -- Counter to limit the number of customers
BEGIN
    -- Display report header
    DBMS_OUTPUT.PUT_LINE('Thrifty Customers');
    DBMS_OUTPUT.PUT_LINE('------------------');

    -- Cursor to fetch customers sorted by amount spent in ascending order
    FOR customer IN (SELECT c.Customer_ID, c.F_Name, c.L_Name, NVL(SUM(i.Amount), 0) AS total_amount
                     FROM Customers c
                     LEFT JOIN Invoices i ON c.Customer_ID = i.Customer_ID
                     GROUP BY c.Customer_ID, c.F_Name
                     ORDER BY total_amount DESC) LOOP

        -- Display customer information
        DBMS_OUTPUT.PUT_LINE('Customer ID: ' || customer.Customer_ID);
        DBMS_OUTPUT.PUT_LINE('Customer Name: ' || customer.F_Name || customer.L_Name);
        DBMS_OUTPUT.PUT_LINE('Total Amount Spent: $' || TO_CHAR(customer.total_amount));
        DBMS_OUTPUT.PUT_LINE('------------------');

        -- Increment the counter
        v_counter := v_counter + 1;

        -- Break the loop when the required number of customers is reached
        EXIT WHEN v_counter = p_num_customers;
    END LOOP;

EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error identifying thrifty customers: ' || SQLERRM);
END;

--Drop the sequence
DROP SEQUENCE ReviewID_SEQ;

-- Create the sequence for Review_ID
CREATE SEQUENCE ReviewID_SEQ START WITH 1 INCREMENT BY 1;

-- Procedure: Add_Review
CREATE OR REPLACE PROCEDURE Add_Review(
    p_reviewer_email IN VARCHAR2,
    p_stars_given IN NUMBER,
    p_product_name IN VARCHAR2,
    p_review_text IN VARCHAR2
) IS
    v_product_id Products.Product_ID%TYPE;
    v_review_id Reviews.Review_ID%TYPE;
BEGIN
    -- Find the product ID using the helper function
    v_product_id := FIND_PRODUCT_ID(p_product_name);

    -- Insert the review into the Reviews table
    INSERT INTO Reviews (Review_ID, Product_ID, ReviewerEmail, StarsGiven, ReviewText)
    VALUES (ReviewID_SEQ.NEXTVAL, v_product_id, p_reviewer_email, p_stars_given, p_review_text);

    DBMS_OUTPUT.PUT_LINE('Review added successfully.');

EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error adding review: ' || SQLERRM);
END;

-- Procedure: Buy_Or_Beware
CREATE OR REPLACE PROCEDURE Buy_Or_Beware(p_top_x IN NUMBER) IS
    CURSOR best_products_cur IS
        SELECT AVG(r.StarsGiven) AS avg_stars,
               p.Product_ID,
               p.Product_Name,
               STDDEV(r.StarsGiven) AS stars_deviation
        FROM Products p
        JOIN Reviews r ON p.Product_ID = r.Product_ID
        GROUP BY p.Product_ID, p.Product_Name
        ORDER BY avg_stars DESC;

    CURSOR worst_products_cur IS
        SELECT AVG(r.StarsGiven) AS avg_stars,
               p.Product_ID,
               p.Product_Name,
               STDDEV(r.StarsGiven) AS stars_deviation
        FROM Products p
        JOIN Reviews r ON p.Product_ID = r.Product_ID
        GROUP BY p.Product_ID, p.Product_Name
        ORDER BY avg_stars ASC;

    v_counter NUMBER := 0;
BEGIN
    -- Print top-rated products
    DBMS_OUTPUT.PUT_LINE('Top rated products:');
    FOR best_product IN best_products_cur LOOP
        EXIT WHEN v_counter >= p_top_x;
        DBMS_OUTPUT.PUT_LINE('Average Stars: ' || best_product.avg_stars ||
                             ' | Product ID: ' || best_product.Product_ID ||
                             ' | Product Name: ' || best_product.Product_Name ||
                             ' | Stars Deviation: ' || best_product.stars_deviation);
        v_counter := v_counter + 1;
    END LOOP;

    v_counter := 0; -- Reset counter for worst-rated products

    -- Print worst-rated products
    DBMS_OUTPUT.PUT_LINE('Buyer Beware: Stay Away from...');
    FOR worst_product IN worst_products_cur LOOP
        EXIT WHEN v_counter >= p_top_x;
        DBMS_OUTPUT.PUT_LINE('Average Stars: ' || worst_product.avg_stars ||
                             ' | Product ID: ' || worst_product.Product_ID ||
                             ' | Product Name: ' || worst_product.Product_Name ||
                             ' | Stars Deviation: ' || worst_product.stars_deviation);
        v_counter := v_counter + 1;
    END LOOP;

EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error in Buy_Or_Beware: ' || SQLERRM);
END;

--Drop the sequence
DROP SEQUENCE Recommendation_ID_SEQ;

-- Create a sequence
CREATE SEQUENCE Recommendation_ID_SEQ START WITH 1 INCREMENT BY 1;

-- Procedure to calculate a recommendation for a customer
CREATE OR REPLACE PROCEDURE Recommend_To_Customer(
    p_CustomerID IN NUMBER
) AS
    v_Customer_ID NUMBER;
    v_F_Name VARCHAR2(50);  -- Adjust the size as per your actual column size
    v_L_Name VARCHAR2(50);  -- Adjust the size as per your actual column size
    v_BoughtProduct_ID NUMBER;
    v_RecommendedProduct_ID NUMBER;

    -- Cursor declaration
    CURSOR cursorCustomers IS
        SELECT DISTINCT c.Customer_ID, c.F_Name, c.L_Name, r.RecommendedProduct_ID AS BoughtProductID
        FROM Customers c
        JOIN Orders o ON c.Customer_ID = o.Customer_ID
        LEFT JOIN Recommendation r ON c.Customer_ID = r.Customer_ID;

BEGIN
    OPEN cursorCustomers;

    FETCH cursorCustomers INTO v_Customer_ID, v_F_Name, v_L_Name, v_BoughtProduct_ID;

    WHILE cursorCustomers%FOUND LOOP
        -- Cursor declaration for recommended products
        FOR recommended_product IN (
            SELECT r.Product_ID
            FROM Reviews r
            WHERE r.Product_ID NOT IN (
                SELECT o.Product_ID
                FROM Orders o
                WHERE o.Customer_ID = v_Customer_ID
            )
            AND r.Product_ID IN (
                SELECT p.Product_ID
                FROM Products p
                WHERE p.ProductCategory_ID IN (
                    SELECT p.ProductCategory_ID
                    FROM Products p
                    WHERE p.Product_ID = v_BoughtProduct_ID
                )
            )
            AND ROWNUM = 1
        ) LOOP
            v_RecommendedProduct_ID := recommended_product.Product_ID;

            -- Insert the recommendation
            INSERT INTO Recommendation(Recommendation_ID, Customer_ID, RecommendedProduct_ID, RecommendationDate)
            VALUES (Recommendation_ID_SEQ.NEXTVAL, v_Customer_ID, v_RecommendedProduct_ID, SYSDATE);

            DBMS_OUTPUT.PUT_LINE('Recommendation added successfully');
        END LOOP;

        FETCH cursorCustomers INTO v_Customer_ID, v_F_Name, v_L_Name, v_BoughtProduct_ID;
    END LOOP;

    CLOSE cursorCustomers;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

-- Procedure to list all customer recommendations
CREATE OR REPLACE PROCEDURE List_Recommendations AS
BEGIN
    FOR recommendation_info IN (
        SELECT c.F_Name AS CustomerName, p.Product_Name AS RecommendedProduct, AVG(r.StarsGiven) AS AverageStars
        FROM Recommendation rec
        JOIN Customers c ON rec.Customer_ID = c.Customer_ID
        JOIN Products p ON rec.RecommendedProduct_ID = p.Product_ID
        JOIN Reviews r ON rec.RecommendedProduct_ID = r.Product_ID
        GROUP BY c.F_Name, p.Product_Name
    ) LOOP
        DBMS_OUTPUT.PUT_LINE('Customer Name: ' || recommendation_info.CustomerName);
        DBMS_OUTPUT.PUT_LINE('Recommended Product: ' || recommendation_info.RecommendedProduct);
        DBMS_OUTPUT.PUT_LINE('Average Stars: ' || recommendation_info.AverageStars);
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

CREATE OR REPLACE PROCEDURE Income_By_State AS
BEGIN
    -- Loop through each state and calculate total income
    FOR state_income IN (
        -- Query to calculate total income by state
        SELECT c.State, SUM(i.Amount) AS TotalIncome
        FROM Invoices i
        JOIN Customers c ON i.Customer_ID = c.Customer_ID
        GROUP BY c.State
    ) LOOP
        -- Print state and total income for each state
        DBMS_OUTPUT.PUT_LINE('State: ' || state_income.State);
        DBMS_OUTPUT.PUT_LINE('Total Income: ' || state_income.TotalIncome);
        DBMS_OUTPUT.PUT_LINE('---------------------------');
    END LOOP;
    -- Handle NO_DATA_FOUND exception if there are no records
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('No data found for income by state.');
        -- Handle other specific exceptions
        WHEN OTHERS THEN
            -- Log the error to an error log table or take appropriate action
            DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

-- Procedure to list the top X best selling products
CREATE OR REPLACE PROCEDURE Best_Selling_Products(
    p_X IN NUMBER
) AS
v_Counter NUMBER := 0; -- Counter variable to track the number of iterations
BEGIN
    -- Loop through the best-selling products
    FOR best_selling_product IN (
        -- Query to calculate the top X best selling products
        SELECT p.Product_Name, pc.ProductCategory_Name, SUM(o.Quantity) AS TotalUnitsSold, SUM(i.Amount) AS TotalAmount
        FROM Products p
        JOIN Orders o ON p.Product_ID = o.Product_ID
        JOIN Product_Category pc ON p.ProductCategory_ID = pc.ProductCategory_ID
        JOIN Invoices i ON o.Order_ID = i.Order_ID
        GROUP BY p.Product_Name, pc.ProductCategory_Name
        ORDER BY TotalUnitsSold DESC
    ) LOOP
        -- Exit the loop when the desired number of products is reached
        v_Counter := v_Counter + 1;
        EXIT WHEN v_Counter > p_X;
        -- Print information about each best-selling product
        DBMS_OUTPUT.PUT_LINE('Product Name: ' || best_selling_product.Product_Name);
        DBMS_OUTPUT.PUT_LINE('Category: ' || best_selling_product.ProductCategory_Name);
        DBMS_OUTPUT.PUT_LINE('Total Units Sold: ' || best_selling_product.TotalUnitsSold);
        DBMS_OUTPUT.PUT_LINE('Total Amount Collected: ' || best_selling_product.TotalAmount);
        DBMS_OUTPUT.PUT_LINE('---------------------------');
    END LOOP;
EXCEPTION
    -- Handle the case when the input parameter is not valid
    WHEN VALUE_ERROR THEN
        DBMS_OUTPUT.PUT_LINE('Error: Invalid input parameter.');
    -- Handle the case when there are no records found
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No data found for best-selling products.');
    -- Handle other specific exceptions (add more as needed)
    WHEN OTHERS THEN
        -- Log the error to an error log table or take appropriate action
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

-- Procedure to identify customers who followed recommended products
CREATE OR REPLACE PROCEDURE Recommendations_Follow_Up AS
BEGIN
    -- Cursor to iterate through recommendation information
    FOR recommendation_info IN (
        SELECT
            c.F_Name,
            p.Product_Name AS Recommended_Product,
            CASE
                -- Check if the product was ordered by the customer
                WHEN o.Order_ID IS NOT NULL THEN 'Recommendation followed'
                ELSE 'Recommendation not followed yet'
            END AS Follow_Up_Status
        FROM
            Recommendation rec
            JOIN Customers c ON rec.Customer_ID = c.Customer_ID
            JOIN Products p ON rec.RecommendedProduct_ID = p.Product_ID
            LEFT JOIN Orders o ON c.Customer_ID = o.Customer_ID AND rec.RecommendedProduct_ID = o.Product_ID
    ) LOOP
        -- Print customer information and follow-up status
        DBMS_OUTPUT.PUT_LINE('Customer Name: ' || recommendation_info.F_Name);
        DBMS_OUTPUT.PUT_LINE('Recommended Product: ' || recommendation_info.Recommended_Product);
        DBMS_OUTPUT.PUT_LINE('Follow-Up Status: ' || recommendation_info.Follow_Up_Status);
        DBMS_OUTPUT.PUT_LINE('---------------------------');
    END LOOP;

EXCEPTION
    -- Handle specific exception when no data is found
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No data found.');
    -- Handle other exceptions
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

-- Procedure to identify products ordered within a time interval
CREATE OR REPLACE PROCEDURE Prod_Order_By_Time_Intvl(
    p_StartDate IN DATE,
    p_EndDate IN DATE
) AS
BEGIN
    -- Loop through each product_info
    FOR product_info IN (
        SELECT p.Product_Name, 
               SUM(o.Quantity) AS TotalUnitsOrdered, 
               COUNT(DISTINCT o.Customer_ID) AS TotalCustomers
        FROM Products p
        JOIN Orders o ON p.Product_ID = o.Product_ID
        WHERE o.Order_Date >= p_StartDate AND o.Order_Date < p_EndDate + 1
        GROUP BY p.Product_Name
    ) LOOP
        -- Print product information
        DBMS_OUTPUT.PUT_LINE('Product Name: ' || product_info.Product_Name);
        DBMS_OUTPUT.PUT_LINE('Total Units Ordered: ' || product_info.TotalUnitsOrdered);
        DBMS_OUTPUT.PUT_LINE('Total Customers: ' || product_info.TotalCustomers);
        DBMS_OUTPUT.PUT_LINE('---------------------------');
    END LOOP;
    
EXCEPTION
    -- Handle specific exception when no data is found
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No data found.');
    -- Handle specific exception when too many rows are found
    WHEN TOO_MANY_ROWS THEN
        DBMS_OUTPUT.PUT_LINE('Too many rows found.');
    -- Handle other exceptions
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

