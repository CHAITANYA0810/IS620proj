Set Serveroutput on;

DROP TABLE Recommendation CASCADE CONSTRAINTS;
DROP TABLE Reviews CASCADE CONSTRAINTS;
DROP TABLE Invoices CASCADE CONSTRAINTS;
DROP TABLE Orders CASCADE CONSTRAINTS;
DROP TABLE Products CASCADE CONSTRAINTS;
DROP TABLE Product_Category CASCADE CONSTRAINTS;
DROP TABLE Credit_Cards CASCADE CONSTRAINTS;
DROP TABLE Customers CASCADE CONSTRAINTS;

CREATE TABLE Customers (
  Customer_ID INT PRIMARY KEY,
  F_Name VARCHAR(50),
  L_Name VARCHAR(50),
  email VARCHAR(100),
  City VARCHAR(50),
  State VARCHAR(50),
  Zip INT
);

CREATE TABLE Credit_Cards (
  Card_number INT PRIMARY KEY, 
  Customer_ID INT,
  Card_type VARCHAR(10),
  Expiration_year INT,
  Expiration_month INT,
  FOREIGN KEY (Customer_ID) REFERENCES Customers(Customer_ID)
);

CREATE TABLE Product_Category(
    ProductCategory_ID NUMBER PRIMARY KEY,
    ProductCategory_Name VARCHAR(30),
    ProductCategory_Desc VARCHAR(100)
    );

CREATE TABLE Products (
    Product_ID NUMBER,
    ProductCategory_ID NUMBER,
    Product_Name VARCHAR(30),
    Avail_Quant NUMBER,
    Unitprice NUMBER,
    primary key (Product_id),
    foreign key (ProductCategory_ID) references Product_Category(ProductCategory_ID)
);

CREATE TABLE Orders (
    Order_ID number,
    Customer_ID number,
    Product_ID number,
    Quantity number,
    Order_Date date,
    primary key (Order_ID),
    foreign key (Customer_ID) references Customers(Customer_ID),
    foreign key (Product_ID) references Products(Product_ID)
);

CREATE TABLE Invoices (
    Invoice_ID NUMBER PRIMARY KEY,
    Order_ID NUMBER REFERENCES Orders(Order_ID),
    Customer_ID NUMBER REFERENCES Customers(Customer_ID),
    CreditCardNumber VARCHAR2(20),
    Amount NUMBER
);

CREATE TABLE Reviews (
    Review_ID NUMBER PRIMARY KEY,
    Product_ID NUMBER REFERENCES Products(Product_ID),
    ReviewerEmail VARCHAR2(255),
    StarsGiven NUMBER(1, 0),
    ReviewText CLOB
);

CREATE TABLE Recommendation (
    Recommendation_ID NUMBER PRIMARY KEY,
    Customer_ID NUMBER REFERENCES Customers(Customer_ID),
    RecommendedProduct_ID NUMBER REFERENCES Products(Product_ID),
    RecommendationDate DATE
);

desc Customers;
desc Credit_Cards;
desc Product_Category;
desc Products;
desc Orders;
desc Invoices;
desc Reviews;
desc Recommendation;

-- Drop existing sequence if it exists
DROP SEQUENCE custom_id_seq;

-- Create a sequence for generating Customer_ID values
CREATE SEQUENCE custom_id_seq START WITH 1;

-- Procedure to add a customer to the Customers table
CREATE OR REPLACE PROCEDURE Add_Customer(
  cust IN INT,
  fnam IN VARCHAR,
  lnam IN VARCHAR,
  mail IN VARCHAR,
  cit IN VARCHAR,
  stat IN VARCHAR,
  zipp IN VARCHAR
) AS
  x Customers%ROWTYPE;
BEGIN
  -- Populate the record with input values
  x.Customer_ID := cust;
  x.F_Name := fnam;
  x.L_Name := lnam;
  x.Email := mail;
  x.City := cit;
  x.State := stat;
  x.Zip := zipp;
  
  -- Insert the record into the Customers table
  INSERT INTO CUSTOMERS VALUES x;
  
  -- Display a message indicating the customer has been added
  DBMS_OUTPUT.PUT_LINE('ADDING CUSTOMER ' || x.F_Name || ' ' || x.L_Name);
END;

-- Function to retrieve the Customer_ID based on first and last names
CREATE OR REPLACE FUNCTION Find_Customer_ID(
  p_email IN Customers.Email%TYPE
) RETURN NUMBER IS
  cid Customers.Customer_ID%TYPE;
BEGIN
  -- Retrieve the Customer_ID based on email
  SELECT Customer_ID INTO cid
  FROM Customers
  WHERE Email = p_email;

  RETURN cid;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    -- Handle case where no matching customer is found
    DBMS_OUTPUT.PUT_LINE('No such customer');
    RETURN -1;
  WHEN TOO_MANY_ROWS THEN
    -- Handle case where more than one customer is found (return the first one)
    DBMS_OUTPUT.PUT_LINE('More than one customer with the email; returning the first one');
    RETURN cid;
END;

-- Procedure to show all customers in a given state along with their credit card details
CREATE OR REPLACE PROCEDURE Show_all_customers_in_state(
  sta IN VARCHAR
) AS
  CURSOR c1 IS
    SELECT F_Name, L_Name, Email, Card_number, Card_type
    FROM Customers, Credit_Cards
    WHERE Customers.Customer_ID = Credit_Cards.Customer_ID AND Customers.State = sta;
BEGIN
  -- Display customers and their credit card details for the specified state
  DBMS_OUTPUT.PUT_LINE('Customers in ' || sta);
  FOR i IN c1 LOOP
    DBMS_OUTPUT.PUT_LINE(i.F_Name || ' ' || i.L_Name || ' | | ' || i.Email || ' | | ' || i.Card_number || ' | | ' || i.Card_type);
  END LOOP;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    -- Handle case where no customers are found in the specified state
    DBMS_OUTPUT.PUT_LINE('No customers found in ' || sta);
END;

-- Adding customers using the Add_Customer procedure
BEGIN
  Add_Customer(custom_id_seq.NEXTVAL, 'Nihanth', 'Malempet', 'nihanth@malempet.com', 'Baltimore', 'MD', '21250');
  Add_Customer(custom_id_seq.NEXTVAL, 'Chaitanya', 'Shetty', 'chaitanya@shetty.com', 'Baltimore', 'MD', '21250');
  Add_Customer(custom_id_seq.NEXTVAL, 'Aye', 'Sha', 'aye@sha.com', 'Baltimore', 'MD', '21250');
  Add_Customer(custom_id_seq.NEXTVAL, 'Aswin', 'Kumar', 'aswin@kumar.com', 'Columbia', 'SC', '44250');
  Add_Customer(custom_id_seq.NEXTVAL, 'Kush', 'Patel', 'kush@patel.com', 'New York', 'NY', '12345');
  Add_Customer(custom_id_seq.NEXTVAL, 'Ashutosh', 'Latwala', 'ashutosh@Latwala.com', 'New York', 'NY', '12345');
END;

--Implementing procedure to add credit card details for finding further details when details of customer including credit card are needed when a state name is given
create or replace procedure Add_CreditCard(cardno in int,CustoID in INT,cardty in VARCHAR,expyear in int,expmonth in int)as
y Credit_Cards%rowtype;
BEGIN
  y.Card_number := cardno;
  y.Customer_ID := CustoID;
  y.Card_type := cardty;
  y.Expiration_year := expyear;
  y.Expiration_month := expmonth;
  INSERT INTO Credit_Cards VALUES y;
    dbms_output.put_line('ADDING CREDIT CARD WITH CARD NUMBER '||y.card_number);
END;

-- Adding credit card details for customers
Begin
 Add_CreditCard(12345,Find_customer_ID('nihanth@malempet.com'),'VISA',2024,10);
 Add_CreditCard(12346,Find_customer_ID('chaitanya@shetty.com'),'VISA',2024,10);
 Add_CreditCard(12347,Find_customer_ID('ashutosh@Latwala.com'),'VISA',2024,09);
 Add_CreditCard(34567,Find_customer_ID('nihanth@malempet.com'),'AMEX',2024,10);
 Add_CreditCard(23456,Find_customer_ID('aye@sha.com'),'MC',2024,09);
 Add_CreditCard(12348,Find_customer_ID('aswin@kumar.com'),'VISA',2025,10);
 Add_CreditCard(45679,Find_customer_ID('kush@patel.com'),'Discover',2025,10);
end;

-- Execute procedure to show all customers in a specified state
exec show_all_customers_in_state('SC');
/

-- Creating a procedure to report credit cards that will expire within the next 2 months from a given date
CREATE OR REPLACE PROCEDURE Report_Cards_Expire(dat IN DATE) AS
BEGIN
  -- Cursor to retrieve customer and credit card details for expiring cards
  FOR s IN (
    SELECT c.l_name, c.f_name, cc.card_number, cc.card_type, cc.expiration_year, cc.expiration_month
    FROM Customers c
    JOIN Credit_Cards cc ON c.customer_id = cc.customer_id
    -- Conditions to filter credit cards expiring within the next 2 months
    WHERE (cc.expiration_year = EXTRACT(YEAR FROM dat) AND EXTRACT(YEAR FROM dat) = EXTRACT(YEAR FROM dat - interval '2' month) AND 
           cc.expiration_month >= EXTRACT(MONTH FROM dat - interval '2' month) AND cc.expiration_month <= EXTRACT(MONTH FROM dat))
           OR (EXTRACT(YEAR FROM dat) > EXTRACT(YEAR FROM dat - interval '2' month) AND cc.expiration_month >= EXTRACT(MONTH FROM dat - interval '2' month))
    -- Ordering the result by last name and first name
    ORDER BY c.l_name, c.f_name
  )
  LOOP
    -- Displaying details of expiring credit cards
    DBMS_OUTPUT.PUT_LINE(
      s.l_name || ', ' || s.f_name || ', ' || s.card_number || ', ' ||
      s.card_type || ', ' || s.expiration_year || ', ' || s.expiration_month
    );
  END LOOP;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    -- Handling case where no data is found
    DBMS_OUTPUT.PUT_LINE('No expiring credit cards found.');
END;

-- Executing the Report_Cards_Expire procedure for a specific date
BEGIN
  DBMS_OUTPUT.PUT_LINE('CARDS WHICH WILL EXPIRE IN THE NEXT 2 MONTHS');
  Report_Cards_Expire(DATE '2024-10-30');
END;

-- Drop sequences
DROP SEQUENCE Category_id_Seq;
DROP SEQUENCE Product_id_Seq;

-- Create the sequence Category_Seq
CREATE SEQUENCE Category_id_Seq START WITH 1 INCREMENT BY 1;
-- Create the sequence Product_Seq
CREATE SEQUENCE Product_id_Seq START WITH 1 INCREMENT BY 1;


------------------------------------------------------------------------------------------------------------------
/* Responsibility #1 (Member_2): Add_Category: This procedure takes as input all necessary information
to insert a new category to the Category table. */
------------------------------------------------------------------------------------------------------------------
-- Procedure to add a new product category
CREATE OR REPLACE PROCEDURE Add_Category(
    p_ProductCategory_Name IN VARCHAR2,
    p_ProductCategory_Desc IN VARCHAR2
) AS
BEGIN
    INSERT INTO Product_Category(ProductCategory_ID, ProductCategory_Name, ProductCategory_Desc)
    VALUES (Category_id_Seq.NEXTVAL, p_ProductCategory_Name, p_ProductCategory_Desc);
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Product category added successfully');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

------------------------------------------------------------------------------------------------------------------
/* Responsibility #2 (Member_2): Add_Product: This procedure takes as input all necessary information 
to insert a new product to the Products table. Use a helper function to find the category ID that is
needed in adding a product. */
------------------------------------------------------------------------------------------------------------------
-- Procedure to add a new product
CREATE OR REPLACE PROCEDURE Add_Product(
    p_Product_Name IN VARCHAR2,
    p_Avail_Quant IN NUMBER,
    p_UnitPrice IN NUMBER,
    p_ProductCategory_Name IN VARCHAR2
) AS
    v_ProductCategory_ID NUMBER;
BEGIN
    -- Find the category ID using the category name
    SELECT ProductCategory_ID INTO v_ProductCategory_ID
    FROM Product_Category
    WHERE ProductCategory_Name = p_ProductCategory_Name;

    -- Insert the product information
    INSERT INTO Products(Product_ID, Product_Name, Avail_Quant, Unitprice, ProductCategory_ID)
    VALUES (Product_id_Seq.NEXTVAL, p_Product_Name, p_Avail_Quant, p_UnitPrice, v_ProductCategory_ID);
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Product added successfully');
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error: Category not found.');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

------------------------------------------------------------------------------------------------------------------
/* Responsibility #3 (Member_2): Update_Inventory: When an order is placed, the Products table must be 
updated with the new remaining quantity. Create a procedure that will take as input the productID
and the units (quantity) of a product in an order, and will update the inventory in the Products 
table to reflect the new quantity after the order.  */
------------------------------------------------------------------------------------------------------------------
-- Procedure to update the inventory
CREATE OR REPLACE PROCEDURE Update_Inventory(
    p_product_id IN NUMBER,
    p_units IN NUMBER
) AS
    v_existing_quantity NUMBER;
BEGIN
    -- Use cursor to fetch existing quantity
    FOR product_rec IN (SELECT Avail_quant FROM Products WHERE product_id = p_product_id) 
    LOOP
        v_existing_quantity := product_rec.Avail_Quant;
    END LOOP;

    -- Update inventory
    UPDATE Products
    SET Avail_quant = v_existing_quantity - p_units
    WHERE product_id = p_product_id;

    DBMS_OUTPUT.PUT_LINE('Inventory updated successfully.');
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error: Product with ID ' || p_product_id || ' not found.');
    WHEN OTHERS THEN
        -- Handle exceptions
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

------------------------------------------------------------------------------------------------------------------
/* Responsibility #4 (Member_2): Report_Inventory: This procedure will display a report of 
available inventory. For each product category print a list with the name of the category and
the quantity of all available products in that category.  */
------------------------------------------------------------------------------------------------------------------
-- Procedure to Report the inventory
CREATE OR REPLACE PROCEDURE Report_Inventory AS
BEGIN
    -- Use cursor to fetch inventory information
    FOR category_rec IN (SELECT ProductCategory_id, ProductCategory_name FROM Product_Category)
    LOOP
        DBMS_OUTPUT.PUT_LINE('Category: ' || category_rec.ProductCategory_name);

        FOR product_rec IN (SELECT product_name, Avail_Quant FROM Products WHERE ProductCategory_id = category_rec.ProductCategory_id)
        LOOP
            DBMS_OUTPUT.PUT_LINE('  Product: ' || product_rec.product_name || ', Quantity: ' || product_rec.Avail_quant);
        END LOOP;
    END LOOP;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error: No data found in the inventory.');
    WHEN OTHERS THEN
        -- Handle exceptions
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

CREATE OR REPLACE FUNCTION FIND_PRODUCT_ID(
    p_product_name IN VARCHAR2
) RETURN NUMBER IS
    v_product_id Products.Product_ID%TYPE;
BEGIN
    SELECT Product_ID
    INTO v_product_id
    FROM Products
    WHERE Product_Name = p_product_name;

    RETURN v_product_id;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        -- Handle exception when product is not found
        DBMS_OUTPUT.PUT_LINE('Error: Product not found.');
        RETURN NULL; -- You can choose to handle this differently based on your requirements
    WHEN OTHERS THEN
        -- Handle other exceptions
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
        RETURN NULL; -- You can choose to handle this differently based on your requirements
END;

DROP SEQUENCE InvoiceID_SEQ;

CREATE SEQUENCE InvoiceID_SEQ START WITH 1 INCREMENT BY 1;

-- Helper Function: FIND_CREDIT_CARD_ID
CREATE OR REPLACE FUNCTION FIND_CREDIT_CARD_ID(p_credit_card_number VARCHAR2)
    RETURN INT
IS
    v_credit_card_id   Credit_Cards.Card_Number%TYPE; -- Assuming CreditCard_Number is unique
BEGIN
    -- Find Credit Card ID based on credit card number
    SELECT Customer_ID
    INTO v_credit_card_id
    FROM Credit_Cards
    WHERE Card_Number = p_credit_card_number;

    RETURN v_credit_card_id;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Credit card not found.');
        RETURN NULL;
END;

------------------------------------------------------------------------------------------------------------------
/* Responsibility #1 (Member_4): Invoice_Customer :- This procedure enters a record in the Invoice table. 
Inputs: Order ID, Customer ID, Credit Card #, Amount. Have used the helper function (FIND_CREDIT_CARD_ID) to 
find the Credit Card ID for the given credit card number. */
------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE Invoice_Customer(
    p_order_id IN Orders.Order_ID%TYPE,
    p_customer_id IN Customers.Customer_ID%TYPE,
    p_credit_card_number IN VARCHAR2,
    p_amount IN NUMBER
)
IS
    v_credit_card_id Credit_Cards.Card_Number%TYPE;
BEGIN
    -- Finding the Credit Card ID based on credit card number using helper function FIND_CREDIT_CARD_ID Which takes in the Creedit_card_number as the input
    v_credit_card_id := FIND_CREDIT_CARD_ID(p_credit_card_number);

    -- Insert record into Invoice table
    INSERT INTO Invoices (Invoice_ID, Order_ID, Customer_ID, CreditCardNumber, Amount)
    VALUES (InvoiceID_Seq.NEXTVAL, p_order_id, p_customer_id, v_credit_card_id, p_amount);

    DBMS_OUTPUT.PUT_LINE('Invoice record added successfully.');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error adding invoice record: ' || SQLERRM);
END;


-- Drop the sequence Order_Seq
DROP SEQUENCE Order_id_Seq;

-- Create the sequence Order_Seq which automatically creates the order ID for new orders that are being placed by the customers.
CREATE SEQUENCE Order_id_Seq START WITH 1 INCREMENT BY 1;

CREATE OR REPLACE PROCEDURE Place_Order(
    p_customer_email IN VARCHAR2,
    p_product_name IN VARCHAR2,
    p_quantity IN NUMBER,
    p_credit_card_number IN VARCHAR2
) AS
    v_customer_id Customers.Customer_ID%TYPE;
    v_product_id Products.Product_ID%TYPE;
    v_order_id Orders.Order_ID%TYPE;
    v_f_name VARCHAR2(50);
    v_l_name VARCHAR2(50);
BEGIN
    -- Split email into parts (simplified)
    -- Note: This is a simple example and may not cover all cases
    v_f_name := SUBSTR(p_customer_email, 1, INSTR(p_customer_email, '@') - 1);
    v_l_name := SUBSTR(p_customer_email, INSTR(p_customer_email, '@') + 1);

    -- Find customer ID using helper function
    v_customer_id := Find_customer_id(p_customer_email);

    -- Find product ID using helper function
    v_product_id := FIND_PRODUCT_ID(p_product_name);

    -- Insert order information
    INSERT INTO Orders(Order_ID, Customer_ID, Product_ID, Quantity, Order_Date)
    VALUES (Order_id_seq.NEXTVAL, v_customer_id, v_product_id, p_quantity, SYSDATE)
    RETURNING Order_ID INTO v_order_id;

    -- Update inventory using the procedure from Member 2
    Update_Inventory(v_product_id, p_quantity);

    -- Invoice the customer using the procedure from Member 4
    --Invoice_Customer(v_order_id, v_customer_id, p_credit_card_number, p_quantity);

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error: Customer or product not found.');
    WHEN OTHERS THEN
        -- Handle exceptions
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

CREATE OR REPLACE PROCEDURE SHOW_ORDERS IS
BEGIN
    FOR order_rec IN (SELECT
                        C.F_name AS Customer_Name,
                        P.Product_Name,
                        O.Quantity,
                        O.Quantity * P.UnitPrice AS Amount_Charged
                      FROM
                        Orders O
                        JOIN Customers C ON O.Customer_ID = C.Customer_ID
                        JOIN Products P ON O.Product_ID = P.Product_ID)
    LOOP
        DBMS_OUTPUT.PUT_LINE('Customer: ' || order_rec.Customer_Name ||
                             ', Product: ' || order_rec.Product_Name ||
                             ', Quantity Ordered: ' || order_rec.Quantity ||
                             ', Amount Charged: ' || order_rec.Amount_Charged);
    END LOOP;

    -- Calculate Grand Total
    DECLARE
       v_grand_total NUMBER;
    BEGIN
      SELECT SUM(O.Quantity * p.UnitPrice) -- Use Quantity from Orders table and UnitPrice from Products table
      INTO v_grand_total
      FROM Orders O
      JOIN Products p ON O.ProductID = p.ProductID; -- Assuming there's a foreign key relationship between Orders and Products
      DBMS_OUTPUT.PUT_LINE('Grand Total Amount of All Orders: ' || v_grand_total);
    END;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

CREATE OR REPLACE PROCEDURE REPORT_ORDERS_BY_STATE (p_state IN VARCHAR2) IS
BEGIN
    FOR order_rec IN (SELECT
                        C.F_Name AS Customer_Name,
                        C.Email,
                        COUNT(*) AS Total_Orders,
                        SUM(O.Quantity * P.UnitPrice) AS Total_Amount
                      FROM
                        Orders O
                        JOIN Customers C ON O.Customer_ID = C.Customer_ID
                        JOIN Products P ON O.Product_ID = P.Product_ID
                      WHERE
                        C.State = p_state
                      GROUP BY
                        C.F_Name, C.Email)
    LOOP
        DBMS_OUTPUT.PUT_LINE('Customer: ' || order_rec.Customer_Name ||
                             ', Email: ' || order_rec.Email ||
                             ', Total Orders: ' || order_rec.Total_Orders ||
                             ', Total Amount Spent: ' || order_rec.Total_Amount);
    END LOOP;

    -- Calculate Grand Total Amount Spent
    DECLARE
        v_grand_total NUMBER;
    BEGIN
        SELECT SUM(O.Quantity * P.UnitPrice)
        INTO v_grand_total
        FROM Orders O
        JOIN Customers C ON O.Customer_ID = C.Customer_ID
        JOIN Products P ON O.Product_ID = P.Product_ID
        WHERE C.State = p_state;

        DBMS_OUTPUT.PUT_LINE('Grand Total Amount Spent from ' || p_state || ': ' || v_grand_total);
    END;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

-- Create a stored procedure to get the product name
CREATE OR REPLACE PROCEDURE Get_Product_Name(
    p_Product_ID IN NUMBER,
    p_Product_Name OUT VARCHAR2
) AS
BEGIN
    SELECT Product_Name INTO p_Product_Name
    FROM Products
    WHERE Product_ID = p_Product_ID;
END;

-- Create the trigger
CREATE OR REPLACE TRIGGER Low_Inventory_Trigger
BEFORE INSERT ON Orders
FOR EACH ROW
DECLARE
    v_Avail_Quant NUMBER;
    v_Product_Name VARCHAR2(100); -- Adjust the size based on your actual column size
BEGIN
    -- Get the product name
    Get_Product_Name(:new.Product_ID, v_Product_Name);

    -- Get the available quantity
    SELECT Avail_Quant INTO v_Avail_Quant
    FROM Products
    WHERE Product_ID = :new.Product_ID;

    -- Check for low inventory
    IF v_Avail_Quant < 50 THEN
        DBMS_OUTPUT.PUT_LINE('Low Inventory Alert: Product ' || :new.Product_ID || ' (' || v_Product_Name || ') is below 50 units.');
    END IF;
END;

-- Procedure to restock a specific product
CREATE OR REPLACE PROCEDURE Restock_Product(
    p_Product_Name IN VARCHAR2,
    p_QuantityToAdd IN NUMBER
) AS
BEGIN
    -- Update the product's available quantity
    UPDATE Products
    SET Avail_Quant = Avail_Quant + p_QuantityToAdd
    WHERE Product_Name = p_Product_Name; -- Corrected the parameter name here
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Product restocked successfully');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

-- Helper Function: FIND_ORDER_ID
CREATE OR REPLACE FUNCTION FIND_ORDER_ID(p_customer_email VARCHAR2, p_product_name VARCHAR2, p_quantity NUMBER)
    RETURN NUMBER
IS
    v_customer_id   Customers.Customer_ID%TYPE;
    v_product_id    Products.Product_ID%TYPE;
    v_order_id      Orders.Order_ID%TYPE;
BEGIN
    -- Use FIND_CUSTOMER_ID, FIND_PRODUCT_ID functions as needed
    -- Assume p_customer_email contains both first and the last name seperated by a space 
    v_customer_id := FIND_CUSTOMER_ID(p_customer_email);
    v_product_id := FIND_PRODUCT_ID(p_product_name);

    -- Find Order ID based on customer, product, and quantity
    SELECT Order_ID
    INTO v_order_id
    FROM Orders
    WHERE Customer_ID = v_customer_id
        AND Product_ID = v_product_id
        AND Quantity = p_quantity;

    RETURN v_order_id;
END;

------------------------------------------------------------------------------------------------------------------
/* Responsibility #2 (Member_4): Report_Best_Customer: The procedure takes as input a dollar amount and will
produce a report of all customers (names, and total amount spent) who have spent
more than the input amount in the online store. */
------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE Report_Best_Customers(
    p_amount_threshold IN NUMBER
)
IS
BEGIN
    -- Display report header
    DBMS_OUTPUT.PUT_LINE('Report of Customers Who Spent More Than $' || TO_CHAR(p_amount_threshold));
    DBMS_OUTPUT.PUT_LINE('--------------------------------------------');
    
    -- Query and display customers who spent more than the specified amount
    FOR cust IN (
        SELECT c.Customer_ID, c.F_Name, SUM(i.Amount) AS total_amount
        FROM Customers c
        JOIN Invoices i ON c.Customer_ID = i.Customer_ID
        GROUP BY c.Customer_ID, c.F_Name
        HAVING SUM(i.Amount) > p_amount_threshold
        ORDER BY total_amount DESC
    ) LOOP
        DBMS_OUTPUT.PUT_LINE('Customer ID: ' || cust.Customer_ID || ', Name: ' || cust.F_Name || ', Total Amount Spent: $' || TO_CHAR(cust.total_amount));
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error generating best customers report: ' || SQLERRM);
END;

------------------------------------------------------------------------------------------------------------------
/* Responsibility #3 (Member_4): Payments_to_CC :- This procedure calculates the fee that the online store must 
pay to credit card companies for the orders placed on it. 
The fees per purchase are: (VISA: 3%, MC: 3%, AMEX:5%, Discover: 2%). */
------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE Payments_to_CC IS
    -- Declare variables
    v_total_visa_fee NUMBER;
    v_total_mc_fee NUMBER;
    v_total_amex_fee NUMBER;
    v_total_discover_fee NUMBER;

BEGIN
    -- Initialize variables
    v_total_visa_fee := 0;
    v_total_mc_fee := 0;
    v_total_amex_fee := 0;
    v_total_discover_fee := 0;

    -- Display report header
    DBMS_OUTPUT.PUT_LINE('Payments to Credit Card Companies');
    DBMS_OUTPUT.PUT_LINE('----------------------------------');

    -- Cursors for fetching payments by credit card type
    FOR payment IN (SELECT c.Card_Type, SUM(i.Amount) AS total_amount
                    FROM Credit_Cards c
                    JOIN Invoices i ON c.Card_Number = i.CreditCardNumber
                    GROUP BY c.Card_Type) LOOP

        -- Calculate fees based on credit card type
        CASE payment.Card_Type
            WHEN 'VISA' THEN
                v_total_visa_fee := payment.total_amount * 0.03;
            WHEN 'MC' THEN
                v_total_mc_fee := payment.total_amount * 0.03;
            WHEN 'AMEX' THEN
                v_total_amex_fee := payment.total_amount * 0.05;
            WHEN 'DISCOVER' THEN
                v_total_discover_fee := payment.total_amount * 0.02;
        END CASE;
    END LOOP;

    -- Print a list in lines each showing the total fee to be paid to each credit card type
    DBMS_OUTPUT.PUT_LINE('VISA Fee: $' || TO_CHAR(v_total_visa_fee));
    DBMS_OUTPUT.PUT_LINE('MC Fee: $' || TO_CHAR(v_total_mc_fee));
    DBMS_OUTPUT.PUT_LINE('AMEX Fee: $' || TO_CHAR(v_total_amex_fee));
    DBMS_OUTPUT.PUT_LINE('DISCOVER Fee: $' || TO_CHAR(v_total_discover_fee));
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error calculating payments to credit card companies: ' || SQLERRM);
END;

------------------------------------------------------------------------------------------------------------------
/* Responsibility #4 (Member_4): Thrifty_Cutomer :- Procedure that takes as input a number X, and 
prints the X most stingy customers based on the dollar amount of purchases
sorted by amount spent in descending order */
------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE Thrifty_Customer(p_num_customers IN NUMBER) IS
    v_counter NUMBER := 0; -- Counter to limit the number of customers
BEGIN
    -- Display report header
    DBMS_OUTPUT.PUT_LINE('Thrifty Customers');
    DBMS_OUTPUT.PUT_LINE('------------------');

    -- Cursor to fetch customers sorted by amount spent in ascending order
    FOR customer IN (SELECT c.Customer_ID, c.F_Name, c.L_Name, NVL(SUM(i.Amount), 0) AS total_amount
                     FROM Customers c
                     LEFT JOIN Invoices i ON c.Customer_ID = i.Customer_ID
                     GROUP BY c.Customer_ID, c.F_Name
                     ORDER BY total_amount DESC) LOOP

        -- Display customer information
        DBMS_OUTPUT.PUT_LINE('Customer ID: ' || customer.Customer_ID);
        DBMS_OUTPUT.PUT_LINE('Customer Name: ' || customer.F_Name || customer.L_Name);
        DBMS_OUTPUT.PUT_LINE('Total Amount Spent: $' || TO_CHAR(customer.total_amount));
        DBMS_OUTPUT.PUT_LINE('------------------');

        -- Increment the counter by 1 to traverse the loop
        v_counter := v_counter + 1;

        -- Break the loop when the required number of customers is reached
        EXIT WHEN v_counter = p_num_customers;
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error identifying thrifty customers: ' || SQLERRM);
END;

--Drop the sequence
DROP SEQUENCE ReviewID_SEQ;

-- Create the sequence for Review_ID
CREATE SEQUENCE ReviewID_SEQ START WITH 1 INCREMENT BY 1;

-- Procedure: Add_Review
CREATE OR REPLACE PROCEDURE Add_Review(
    p_reviewer_email IN VARCHAR2,
    p_stars_given IN NUMBER,
    p_product_name IN VARCHAR2,
    p_review_text IN VARCHAR2
) IS
    v_product_id Products.Product_ID%TYPE;
    v_review_id Reviews.Review_ID%TYPE;
BEGIN
    -- Find the product ID using the helper function
    v_product_id := FIND_PRODUCT_ID(p_product_name);

    -- Insert the review into the Reviews table
    INSERT INTO Reviews (Review_ID, Product_ID, ReviewerEmail, StarsGiven, ReviewText)
    VALUES (ReviewID_SEQ.NEXTVAL, v_product_id, p_reviewer_email, p_stars_given, p_review_text);

    DBMS_OUTPUT.PUT_LINE('Review added successfully.');

EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error adding review: ' || SQLERRM);
END;

-- Procedure: Buy_Or_Beware
CREATE OR REPLACE PROCEDURE Buy_Or_Beware(p_top_x IN NUMBER) IS
    CURSOR best_products_cur IS
        SELECT AVG(r.StarsGiven) AS avg_stars,
               p.Product_ID,
               p.Product_Name,
               STDDEV(r.StarsGiven) AS stars_deviation
        FROM Products p
        JOIN Reviews r ON p.Product_ID = r.Product_ID
        GROUP BY p.Product_ID, p.Product_Name
        ORDER BY avg_stars DESC;

    CURSOR worst_products_cur IS
        SELECT AVG(r.StarsGiven) AS avg_stars,
               p.Product_ID,
               p.Product_Name,
               STDDEV(r.StarsGiven) AS stars_deviation
        FROM Products p
        JOIN Reviews r ON p.Product_ID = r.Product_ID
        GROUP BY p.Product_ID, p.Product_Name
        ORDER BY avg_stars ASC;

    v_counter NUMBER := 0;
BEGIN
    -- Print top-rated products
    DBMS_OUTPUT.PUT_LINE('Top rated products:');
    FOR best_product IN best_products_cur LOOP
        EXIT WHEN v_counter >= p_top_x;
        DBMS_OUTPUT.PUT_LINE('Average Stars: ' || best_product.avg_stars ||
                             ' | Product ID: ' || best_product.Product_ID ||
                             ' | Product Name: ' || best_product.Product_Name ||
                             ' | Stars Deviation: ' || best_product.stars_deviation);
        v_counter := v_counter + 1;
    END LOOP;

    v_counter := 0; -- Reset counter for worst-rated products

    -- Print worst-rated products
    DBMS_OUTPUT.PUT_LINE('Buyer Beware: Stay Away from...');
    FOR worst_product IN worst_products_cur LOOP
        EXIT WHEN v_counter >= p_top_x;
        DBMS_OUTPUT.PUT_LINE('Average Stars: ' || worst_product.avg_stars ||
                             ' | Product ID: ' || worst_product.Product_ID ||
                             ' | Product Name: ' || worst_product.Product_Name ||
                             ' | Stars Deviation: ' || worst_product.stars_deviation);
        v_counter := v_counter + 1;
    END LOOP;

EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error in Buy_Or_Beware: ' || SQLERRM);
END;

--Drop the sequence
DROP SEQUENCE Recommendation_ID_SEQ;

-- Create a sequence
CREATE SEQUENCE Recommendation_ID_SEQ START WITH 1 INCREMENT BY 1;

-- Procedure to calculate a recommendation for a customer
CREATE OR REPLACE PROCEDURE Recommend_To_Customer(
    p_CustomerID IN NUMBER
) AS
    v_Customer_ID NUMBER;
    v_F_Name VARCHAR2(50);  -- Adjust the size as per your actual column size
    v_L_Name VARCHAR2(50);  -- Adjust the size as per your actual column size
    v_BoughtProduct_ID NUMBER;
    v_RecommendedProduct_ID NUMBER;

    -- Cursor declaration
    CURSOR cursorCustomers IS
        SELECT DISTINCT c.Customer_ID, c.F_Name, c.L_Name, r.RecommendedProduct_ID AS BoughtProductID
        FROM Customers c
        JOIN Orders o ON c.Customer_ID = o.Customer_ID
        LEFT JOIN Recommendation r ON c.Customer_ID = r.Customer_ID;

BEGIN
    OPEN cursorCustomers;

    FETCH cursorCustomers INTO v_Customer_ID, v_F_Name, v_L_Name, v_BoughtProduct_ID;

    WHILE cursorCustomers%FOUND LOOP
        -- Cursor declaration for recommended products
        FOR recommended_product IN (
            SELECT r.Product_ID
            FROM Reviews r
            WHERE r.Product_ID NOT IN (
                SELECT o.Product_ID
                FROM Orders o
                WHERE o.Customer_ID = v_Customer_ID
            )
            AND r.Product_ID IN (
                SELECT p.Product_ID
                FROM Products p
                WHERE p.ProductCategory_ID IN (
                    SELECT p.ProductCategory_ID
                    FROM Products p
                    WHERE p.Product_ID = v_BoughtProduct_ID
                )
            )
            AND ROWNUM = 1
        ) LOOP
            v_RecommendedProduct_ID := recommended_product.Product_ID;

            -- Insert the recommendation
            INSERT INTO Recommendation(Recommendation_ID, Customer_ID, RecommendedProduct_ID, RecommendationDate)
            VALUES (Recommendation_ID_SEQ.NEXTVAL, v_Customer_ID, v_RecommendedProduct_ID, SYSDATE);

            DBMS_OUTPUT.PUT_LINE('Recommendation added successfully');
        END LOOP;

        FETCH cursorCustomers INTO v_Customer_ID, v_F_Name, v_L_Name, v_BoughtProduct_ID;
    END LOOP;

    CLOSE cursorCustomers;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

-- Procedure to list all customer recommendations
CREATE OR REPLACE PROCEDURE List_Recommendations AS
BEGIN
    FOR recommendation_info IN (
        SELECT c.F_Name AS CustomerName, p.Product_Name AS RecommendedProduct, AVG(r.StarsGiven) AS AverageStars
        FROM Recommendation rec
        JOIN Customers c ON rec.Customer_ID = c.Customer_ID
        JOIN Products p ON rec.RecommendedProduct_ID = p.Product_ID
        JOIN Reviews r ON rec.RecommendedProduct_ID = r.Product_ID
        GROUP BY c.F_Name, p.Product_Name
    ) LOOP
        DBMS_OUTPUT.PUT_LINE('Customer Name: ' || recommendation_info.CustomerName);
        DBMS_OUTPUT.PUT_LINE('Recommended Product: ' || recommendation_info.RecommendedProduct);
        DBMS_OUTPUT.PUT_LINE('Average Stars: ' || recommendation_info.AverageStars);
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

CREATE OR REPLACE PROCEDURE Income_By_State AS
BEGIN
    -- Loop through each state and calculate total income
    FOR state_income IN (
        -- Query to calculate total income by state
        SELECT c.State, SUM(i.Amount) AS TotalIncome
        FROM Invoices i
        JOIN Customers c ON i.Customer_ID = c.Customer_ID
        GROUP BY c.State
    ) LOOP
        -- Print state and total income for each state
        DBMS_OUTPUT.PUT_LINE('State: ' || state_income.State);
        DBMS_OUTPUT.PUT_LINE('Total Income: ' || state_income.TotalIncome);
        DBMS_OUTPUT.PUT_LINE('---------------------------');
    END LOOP;
    -- Handle NO_DATA_FOUND exception if there are no records
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('No data found for income by state.');
        -- Handle other specific exceptions
        WHEN OTHERS THEN
            -- Log the error to an error log table or take appropriate action
            DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

-- Procedure to list the top X best selling products
CREATE OR REPLACE PROCEDURE Best_Selling_Products(
    p_X IN NUMBER
) AS
v_Counter NUMBER := 0; -- Counter variable to track the number of iterations
BEGIN
    -- Loop through the best-selling products
    FOR best_selling_product IN (
        -- Query to calculate the top X best selling products
        SELECT p.Product_Name, pc.ProductCategory_Name, SUM(o.Quantity) AS TotalUnitsSold, SUM(i.Amount) AS TotalAmount
        FROM Products p
        JOIN Orders o ON p.Product_ID = o.Product_ID
        JOIN Product_Category pc ON p.ProductCategory_ID = pc.ProductCategory_ID
        JOIN Invoices i ON o.Order_ID = i.Order_ID
        GROUP BY p.Product_Name, pc.ProductCategory_Name
        ORDER BY TotalUnitsSold DESC
    ) LOOP
        -- Exit the loop when the desired number of products is reached
        v_Counter := v_Counter + 1;
        EXIT WHEN v_Counter > p_X;
        -- Print information about each best-selling product
        DBMS_OUTPUT.PUT_LINE('Product Name: ' || best_selling_product.Product_Name);
        DBMS_OUTPUT.PUT_LINE('Category: ' || best_selling_product.ProductCategory_Name);
        DBMS_OUTPUT.PUT_LINE('Total Units Sold: ' || best_selling_product.TotalUnitsSold);
        DBMS_OUTPUT.PUT_LINE('Total Amount Collected: ' || best_selling_product.TotalAmount);
        DBMS_OUTPUT.PUT_LINE('---------------------------');
    END LOOP;
EXCEPTION
    -- Handle the case when the input parameter is not valid
    WHEN VALUE_ERROR THEN
        DBMS_OUTPUT.PUT_LINE('Error: Invalid input parameter.');
    -- Handle the case when there are no records found
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No data found for best-selling products.');
    -- Handle other specific exceptions (add more as needed)
    WHEN OTHERS THEN
        -- Log the error to an error log table or take appropriate action
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

-- Procedure to identify customers who followed recommended products
CREATE OR REPLACE PROCEDURE Recommendations_Follow_Up AS
BEGIN
    -- Cursor to iterate through recommendation information
    FOR recommendation_info IN (
        SELECT
            c.F_Name,
            p.Product_Name AS Recommended_Product,
            CASE
                -- Check if the product was ordered by the customer
                WHEN o.Order_ID IS NOT NULL THEN 'Recommendation followed'
                ELSE 'Recommendation not followed yet'
            END AS Follow_Up_Status
        FROM
            Recommendation rec
            JOIN Customers c ON rec.Customer_ID = c.Customer_ID
            JOIN Products p ON rec.RecommendedProduct_ID = p.Product_ID
            LEFT JOIN Orders o ON c.Customer_ID = o.Customer_ID AND rec.RecommendedProduct_ID = o.Product_ID
    ) LOOP
        -- Print customer information and follow-up status
        DBMS_OUTPUT.PUT_LINE('Customer Name: ' || recommendation_info.F_Name);
        DBMS_OUTPUT.PUT_LINE('Recommended Product: ' || recommendation_info.Recommended_Product);
        DBMS_OUTPUT.PUT_LINE('Follow-Up Status: ' || recommendation_info.Follow_Up_Status);
        DBMS_OUTPUT.PUT_LINE('---------------------------');
    END LOOP;

EXCEPTION
    -- Handle specific exception when no data is found
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No data found.');
    -- Handle other exceptions
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

-- Procedure to identify products ordered within a time interval
CREATE OR REPLACE PROCEDURE Prod_Order_By_Time_Intvl(
    p_StartDate IN DATE,
    p_EndDate IN DATE
) AS
BEGIN
    -- Loop through each product_info
    FOR product_info IN (
        SELECT p.Product_Name, 
               SUM(o.Quantity) AS TotalUnitsOrdered, 
               COUNT(DISTINCT o.Customer_ID) AS TotalCustomers
        FROM Products p
        JOIN Orders o ON p.Product_ID = o.Product_ID
        WHERE o.Order_Date >= p_StartDate AND o.Order_Date < p_EndDate + 1
        GROUP BY p.Product_Name
    ) LOOP
        -- Print product information
        DBMS_OUTPUT.PUT_LINE('Product Name: ' || product_info.Product_Name);
        DBMS_OUTPUT.PUT_LINE('Total Units Ordered: ' || product_info.TotalUnitsOrdered);
        DBMS_OUTPUT.PUT_LINE('Total Customers: ' || product_info.TotalCustomers);
        DBMS_OUTPUT.PUT_LINE('---------------------------');
    END LOOP;
    
EXCEPTION
    -- Handle specific exception when no data is found
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No data found.');
    -- Handle specific exception when too many rows are found
    WHEN TOO_MANY_ROWS THEN
        DBMS_OUTPUT.PUT_LINE('Too many rows found.');
    -- Handle other exceptions
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

